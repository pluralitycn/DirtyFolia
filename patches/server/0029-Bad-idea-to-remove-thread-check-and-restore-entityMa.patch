From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: FlyTeam <81072191+killerprojecte@users.noreply.github.com>
Date: Mon, 11 Sep 2023 10:50:08 +0000
Subject: [PATCH] Bad idea to remove thread check and restore entityMap


diff --git a/src/main/java/io/papermc/paper/chunk/system/RegionizedPlayerChunkLoader.java b/src/main/java/io/papermc/paper/chunk/system/RegionizedPlayerChunkLoader.java
index c5df121d6194a97b20dc390698991b9c72dba538..64e51ea4f42d603cb2025fc10037de1a5bc71235 100644
--- a/src/main/java/io/papermc/paper/chunk/system/RegionizedPlayerChunkLoader.java
+++ b/src/main/java/io/papermc/paper/chunk/system/RegionizedPlayerChunkLoader.java
@@ -124,7 +124,7 @@ public class RegionizedPlayerChunkLoader {
     }
 
     public void addPlayer(final ServerPlayer player) {
-        TickThread.ensureTickThread(player, "Cannot add player to player chunk loader async");
+        //TickThread.ensureTickThread(player, "Cannot add player to player chunk loader async");
         if (!player.isRealPlayer) {
             return;
         }
@@ -147,7 +147,7 @@ public class RegionizedPlayerChunkLoader {
     }
 
     public void removePlayer(final ServerPlayer player) {
-        TickThread.ensureTickThread(player, "Cannot remove player from player chunk loader async");
+        //TickThread.ensureTickThread(player, "Cannot remove player from player chunk loader async");
         if (!player.isRealPlayer) {
             return;
         }
@@ -232,7 +232,7 @@ public class RegionizedPlayerChunkLoader {
     }
 
     public void tick() {
-        TickThread.ensureTickThread("Cannot tick player chunk loader async");
+        //TickThread.ensureTickThread("Cannot tick player chunk loader async");
         long currTime = System.nanoTime();
         for (final ServerPlayer player : new java.util.ArrayList<>(this.world.getLocalPlayers())) { // Folia - region threding
             final PlayerChunkLoaderData loader = player.chunkLoader;
@@ -672,7 +672,7 @@ public class RegionizedPlayerChunkLoader {
         }
 
         void updateQueues(final long time) {
-            TickThread.ensureTickThread(this.player, "Cannot tick player chunk loader async");
+            //TickThread.ensureTickThread(this.player, "Cannot tick player chunk loader async");
             if (this.removed) {
                 throw new IllegalStateException("Ticking removed player chunk loader");
             }
@@ -890,7 +890,7 @@ public class RegionizedPlayerChunkLoader {
         }
 
         void add() {
-            TickThread.ensureTickThread(this.player, "Cannot add player asynchronously");
+            //TickThread.ensureTickThread(this.player, "Cannot add player asynchronously");
             if (this.removed) {
                 throw new IllegalStateException("Adding removed player chunk loader");
             }
@@ -936,7 +936,7 @@ public class RegionizedPlayerChunkLoader {
         }
 
         void update() {
-            TickThread.ensureTickThread(this.player, "Cannot update player asynchronously");
+            //TickThread.ensureTickThread(this.player, "Cannot update player asynchronously");
             if (this.removed) {
                 throw new IllegalStateException("Updating removed player chunk loader");
             }
@@ -1085,7 +1085,7 @@ public class RegionizedPlayerChunkLoader {
         }
 
         void remove() {
-            TickThread.ensureTickThread(this.player, "Cannot add player asynchronously");
+            //TickThread.ensureTickThread(this.player, "Cannot add player asynchronously");
             if (this.removed) {
                 throw new IllegalStateException("Removing removed player chunk loader");
             }
diff --git a/src/main/java/io/papermc/paper/chunk/system/entity/EntityLookup.java b/src/main/java/io/papermc/paper/chunk/system/entity/EntityLookup.java
index 90ff9a00dc287bfb60d16100c2cca32d60ac7534..d232093e26259157066e56f384dfa471896822a1 100644
--- a/src/main/java/io/papermc/paper/chunk/system/entity/EntityLookup.java
+++ b/src/main/java/io/papermc/paper/chunk/system/entity/EntityLookup.java
@@ -240,7 +240,7 @@ public final class EntityLookup implements LevelEntityGetter<Entity> {
 
     public void entityStatusChange(final Entity entity, final ChunkEntitySlices slices, final Visibility oldVisibility, final Visibility newVisibility, final boolean moved,
                                    final boolean created, final boolean destroyed) {
-        TickThread.ensureTickThread(entity, "Entity status change must only happen on the main thread");
+        //TickThread.ensureTickThread(entity, "Entity status change must only happen on the main thread");
 
         if (entity.updatingSectionStatus) {
             // recursive status update
@@ -470,7 +470,7 @@ public final class EntityLookup implements LevelEntityGetter<Entity> {
         final int sectionX = entity.sectionX;
         final int sectionY = entity.sectionY;
         final int sectionZ = entity.sectionZ;
-        TickThread.ensureTickThread(this.world, sectionX, sectionZ, "Cannot remove entity off-main");
+        //TickThread.ensureTickThread(this.world, sectionX, sectionZ, "Cannot remove entity off-main");
         if (!entity.isRemoved()) {
             throw new IllegalStateException("Only call Entity#setRemoved to remove an entity");
         }
@@ -504,7 +504,7 @@ public final class EntityLookup implements LevelEntityGetter<Entity> {
 
     private ChunkEntitySlices moveEntity(final Entity entity) {
         // ensure we own the entity
-        TickThread.ensureTickThread(entity, "Cannot move entity off-main");
+        //TickThread.ensureTickThread(entity, "Cannot move entity off-main");
 
         final BlockPos newPos = entity.blockPosition();
         final int newSectionX = newPos.getX() >> 4;
@@ -516,10 +516,10 @@ public final class EntityLookup implements LevelEntityGetter<Entity> {
         }
 
         // ensure the new section is owned by this tick thread
-        TickThread.ensureTickThread(this.world, newSectionX, newSectionZ, "Cannot move entity off-main");
+        //TickThread.ensureTickThread(this.world, newSectionX, newSectionZ, "Cannot move entity off-main");
 
         // ensure the old section is owned by this tick thread
-        TickThread.ensureTickThread(this.world, entity.sectionX, entity.sectionZ, "Cannot move entity off-main");
+        //TickThread.ensureTickThread(this.world, entity.sectionX, entity.sectionZ, "Cannot move entity off-main");
 
         final ChunkEntitySlices old = this.getChunk(entity.sectionX, entity.sectionZ);
         final ChunkEntitySlices slices = this.getOrCreateChunk(newSectionX, newSectionZ);
@@ -737,7 +737,7 @@ public final class EntityLookup implements LevelEntityGetter<Entity> {
     }
 
     public void entitySectionLoad(final int chunkX, final int chunkZ, final ChunkEntitySlices slices) {
-        TickThread.ensureTickThread(this.world, chunkX, chunkZ, "Cannot load in entity section off-main");
+        //TickThread.ensureTickThread(this.world, chunkX, chunkZ, "Cannot load in entity section off-main");
         synchronized (this) {
             final ChunkEntitySlices curr = this.getChunk(chunkX, chunkZ);
             if (curr != null) {
@@ -753,7 +753,7 @@ public final class EntityLookup implements LevelEntityGetter<Entity> {
     }
 
     public void entitySectionUnload(final int chunkX, final int chunkZ) {
-        TickThread.ensureTickThread(this.world, chunkX, chunkZ, "Cannot unload entity section off-main");
+        //TickThread.ensureTickThread(this.world, chunkX, chunkZ, "Cannot unload entity section off-main");
         this.removeChunk(chunkX, chunkZ);
     }
 
diff --git a/src/main/java/io/papermc/paper/chunk/system/poi/PoiChunk.java b/src/main/java/io/papermc/paper/chunk/system/poi/PoiChunk.java
index d72041aa814ff179e6e29a45dcd359a91d426d47..47dc96a9971798a4dc1f2e88ec2860f930ed48b7 100644
--- a/src/main/java/io/papermc/paper/chunk/system/poi/PoiChunk.java
+++ b/src/main/java/io/papermc/paper/chunk/system/poi/PoiChunk.java
@@ -50,7 +50,7 @@ public final class PoiChunk {
     }
 
     public void load() {
-        TickThread.ensureTickThread(this.world, this.chunkX, this.chunkZ, "Loading in poi chunk off-main");
+        //TickThread.ensureTickThread(this.world, this.chunkX, this.chunkZ, "Loading in poi chunk off-main");
         if (this.loaded) {
             return;
         }
diff --git a/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkHolderManager.java b/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkHolderManager.java
index 793dd089426a180ed35880e4cbc21b273074f9fa..ae9b199bf36dd98a8e30ea679b79127184dc7d19 100644
--- a/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkHolderManager.java
+++ b/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkHolderManager.java
@@ -245,7 +245,7 @@ public final class ChunkHolderManager {
     }
     public void close(final boolean save, final boolean halt, final boolean first, final boolean last, final boolean checkRegions) {
         // Folia end - region threading
-        TickThread.ensureTickThread("Closing world off-main");
+        //TickThread.ensureTickThread("Closing world off-main");
         if (first && halt) { // Folia - region threading
             LOGGER.info("Waiting 60s for chunk system to halt for world '" + this.world.getWorld().getName() + "'");
             if (!this.taskScheduler.halt(true, TimeUnit.SECONDS.toNanos(60L))) {
@@ -982,7 +982,7 @@ public final class ChunkHolderManager {
     private final AtomicLong entityLoadCounter = new AtomicLong();
 
     public ChunkEntitySlices getOrCreateEntityChunk(final int chunkX, final int chunkZ, final boolean transientChunk) {
-        TickThread.ensureTickThread(this.world, chunkX, chunkZ, "Cannot create entity chunk off-main");
+        //TickThread.ensureTickThread(this.world, chunkX, chunkZ, "Cannot create entity chunk off-main");
         ChunkEntitySlices ret;
 
         NewChunkHolder current = this.getChunkHolder(chunkX, chunkZ);
@@ -1069,7 +1069,7 @@ public final class ChunkHolderManager {
     private final AtomicLong poiLoadCounter = new AtomicLong();
 
     public PoiChunk loadPoiChunk(final int chunkX, final int chunkZ) {
-        TickThread.ensureTickThread(this.world, chunkX, chunkZ, "Cannot create poi chunk off-main");
+        //TickThread.ensureTickThread(this.world, chunkX, chunkZ, "Cannot create poi chunk off-main");
         PoiChunk ret;
 
         NewChunkHolder current = this.getChunkHolder(chunkX, chunkZ);
@@ -1209,7 +1209,7 @@ public final class ChunkHolderManager {
 
     // note: never call while inside the chunk system, this will absolutely break everything
     public void processUnloads() {
-        TickThread.ensureTickThread("Cannot unload chunks off-main");
+        //TickThread.ensureTickThread("Cannot unload chunks off-main");
 
         if (BLOCK_TICKET_UPDATES.get() == Boolean.TRUE) {
             throw new IllegalStateException("Cannot unload chunks recursively");
@@ -1484,7 +1484,7 @@ public final class ChunkHolderManager {
     }
 
     private boolean processTicketUpdates(final boolean checkLocks, final boolean processFullUpdates, List<ChunkProgressionTask> scheduledTasks) {
-        TickThread.ensureTickThread("Cannot process ticket levels off-main");
+        //TickThread.ensureTickThread("Cannot process ticket levels off-main");
         if (BLOCK_TICKET_UPDATES.get() == Boolean.TRUE) {
             throw new IllegalStateException("Cannot update ticket level while unloading chunks or updating entity manager");
         }
diff --git a/src/main/java/io/papermc/paper/chunk/system/scheduling/NewChunkHolder.java b/src/main/java/io/papermc/paper/chunk/system/scheduling/NewChunkHolder.java
index c88e0fb3efc500f53bf224c84760893e2be5f634..bad8312c5acb57f03e89e56fecbcd5f9302fffd6 100644
--- a/src/main/java/io/papermc/paper/chunk/system/scheduling/NewChunkHolder.java
+++ b/src/main/java/io/papermc/paper/chunk/system/scheduling/NewChunkHolder.java
@@ -75,7 +75,7 @@ public final class NewChunkHolder {
     private CompoundTag pendingEntityChunk;
 
     ChunkEntitySlices loadInEntityChunk(final boolean transientChunk) {
-        TickThread.ensureTickThread(this.world, this.chunkX, this.chunkZ, "Cannot sync load entity data off-main");
+        //TickThread.ensureTickThread(this.world, this.chunkX, this.chunkZ, "Cannot sync load entity data off-main");
         final CompoundTag entityChunk;
         final ChunkEntitySlices ret;
         final ReentrantAreaLock.Node schedulingLock = this.scheduler.schedulingLockArea.lock(this.chunkX, this.chunkZ);
@@ -1269,7 +1269,7 @@ public final class NewChunkHolder {
 
     // only to be called on the main thread, no locks need to be held
     public boolean handleFullStatusChange(final List<NewChunkHolder> changedFullStatus) {
-        TickThread.ensureTickThread(this.world, this.chunkX, this.chunkZ, "Cannot update full status thread off-main");
+        //TickThread.ensureTickThread(this.world, this.chunkX, this.chunkZ, "Cannot update full status thread off-main");
 
         boolean ret = false;
 
diff --git a/src/main/java/io/papermc/paper/threadedregions/EntityScheduler.java b/src/main/java/io/papermc/paper/threadedregions/EntityScheduler.java
index 62484ebf4550b05182f693a3180bbac5d5fd906d..ee491389207b82a9b16954e774dbdf219b0ab40f 100644
--- a/src/main/java/io/papermc/paper/threadedregions/EntityScheduler.java
+++ b/src/main/java/io/papermc/paper/threadedregions/EntityScheduler.java
@@ -140,7 +140,7 @@ public final class EntityScheduler {
     public void executeTick() {
         final Entity thisEntity = this.entity.getHandleRaw();
 
-        TickThread.ensureTickThread(thisEntity, "May not tick entity scheduler asynchronously");
+        //TickThread.ensureTickThread(thisEntity, "May not tick entity scheduler asynchronously");
         final List<ScheduledTask> toRun;
         synchronized (this.stateLock) {
             if (this.tickCount == RETIRED_TICK_COUNT) {
diff --git a/src/main/java/io/papermc/paper/threadedregions/RegionizedWorldData.java b/src/main/java/io/papermc/paper/threadedregions/RegionizedWorldData.java
index 65c4e158d81ac5c5788cf4dcb379061aebd23dcd..0b3bd5abbcd40ffc2c374cff92833a760a1c0fd4 100644
--- a/src/main/java/io/papermc/paper/threadedregions/RegionizedWorldData.java
+++ b/src/main/java/io/papermc/paper/threadedregions/RegionizedWorldData.java
@@ -599,7 +599,7 @@ public final class RegionizedWorldData {
     // Note that we can only ever not own the event data when the chunk unloads, and so I've decided to
     // make the code easier by simply discarding it in such an event
     public void pushBlockEvent(final BlockEventData blockEventData) {
-        TickThread.ensureTickThread(this.world, blockEventData.pos(), "Cannot queue block even data async");
+        //TickThread.ensureTickThread(this.world, blockEventData.pos(), "Cannot queue block even data async");
         this.blockEvents.add(blockEventData);
     }
 
@@ -640,7 +640,7 @@ public final class RegionizedWorldData {
 
     // tile entity ticking
     public void addBlockEntityTicker(final TickingBlockEntity ticker) {
-        TickThread.ensureTickThread(this.world, ticker.getPos(), "Tile entity must be owned by current region");
+        //TickThread.ensureTickThread(this.world, ticker.getPos(), "Tile entity must be owned by current region");
 
         (this.tickingBlockEntities ? this.pendingBlockEntityTickers : this.blockEntityTickers).add(ticker);
     }
diff --git a/src/main/java/net/minecraft/server/level/ChunkMap.java b/src/main/java/net/minecraft/server/level/ChunkMap.java
index 6885961c7eaa07b8b25e48ca0e33e310379f6114..8d37807ccb2dc09a35b8e9ff8e73c493b0fd8467 100644
--- a/src/main/java/net/minecraft/server/level/ChunkMap.java
+++ b/src/main/java/net/minecraft/server/level/ChunkMap.java
@@ -148,7 +148,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     public final StructureTemplateManager structureTemplateManager; // Paper - rewrite chunk system
     private final String storageName;
     //private final PlayerMap playerMap; // Folia - region threading
-    //public final Int2ObjectMap<ChunkMap.TrackedEntity> entityMap; // Folia - region threading
+    public final Int2ObjectMap<ChunkMap.TrackedEntity> entityMap; // Folia - region threading
     private final Long2ByteMap chunkTypeCache;
     private final Long2LongMap chunkSaveCooldowns;
     private final Queue<Runnable> unloadQueue;
@@ -273,7 +273,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         // Paper - rewrite chunk system
         this.tickingGenerated = new AtomicInteger();
         //this.playerMap = new PlayerMap(); // Folia - region threading
-        //this.entityMap = new Int2ObjectOpenHashMap(); // Folia - region threading
+        this.entityMap = new Int2ObjectOpenHashMap(); // Folia - region threading
         this.chunkTypeCache = new Long2ByteOpenHashMap();
         this.chunkSaveCooldowns = new Long2LongOpenHashMap();
         this.unloadQueue = Queues.newConcurrentLinkedQueue();
@@ -716,8 +716,8 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     }
 
     public void updateChunkTracking(ServerPlayer player, ChunkPos pos, MutableObject<java.util.Map<Object, ClientboundLevelChunkWithLightPacket>> packet, boolean oldWithinViewDistance, boolean newWithinViewDistance) { // Paper - public // Paper - Anti-Xray - Bypass
-        io.papermc.paper.util.TickThread.ensureTickThread(this.level, pos, "May not update chunk tracking for chunk async"); // Paper - replace chunk loader system
-        io.papermc.paper.util.TickThread.ensureTickThread(player, "May not update chunk tracking for player async"); // Paper - replace chunk loader system
+        //io.papermc.paper.util.TickThread.ensureTickThread(this.level, pos, "May not update chunk tracking for chunk async"); // Paper - replace chunk loader system
+        //io.papermc.paper.util.TickThread.ensureTickThread(player, "May not update chunk tracking for player async"); // Paper - replace chunk loader system
         if (player.level() == this.level) {
             ChunkHolder playerchunk = this.getVisibleChunkIfPresent(pos.toLong()); // Paper - replace chunk loader system - move up
             if (newWithinViewDistance && !oldWithinViewDistance) {
@@ -1074,6 +1074,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
                     ChunkMap.TrackedEntity playerchunkmap_entitytracker = new ChunkMap.TrackedEntity(entity, i, j, entitytypes.trackDeltas());
 
                     entity.tracker = playerchunkmap_entitytracker; // Paper - Fast access to tracker
+                    entityMap.put(entity.getId(), entity.tracker);
                     // Folia - region threading
                     playerchunkmap_entitytracker.updatePlayers(this.level.getLocalPlayers()); // Paper - don't search all players // Folia - region threading
                     if (entity instanceof ServerPlayer) {
@@ -1084,6 +1085,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
                         for (Entity possible : this.level.getCurrentWorldData().getLocalEntities()) {
                             if (possible.tracker != null) {
                                 possible.tracker.updatePlayer(entityplayer);
+                                entityMap.put(possible.getId(), possible.tracker);
                             }
                         }
                         // Folia end - region threading
@@ -1129,6 +1131,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
             tracker.updatePlayers(players);
             tracker.removeNonTickThreadPlayers();
             tracker.serverEntity.sendChanges();
+            this.entityMap.put(entity.getId(), tracker);
         }
         // Folia end - region threading
     }
diff --git a/src/main/java/net/minecraft/server/level/ServerChunkCache.java b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
index 364229c0a2945cf093bc448b7c3d9fafebab418f..9159d89d14ac80dd9b08d2a63a74c09a12928abe 100644
--- a/src/main/java/net/minecraft/server/level/ServerChunkCache.java
+++ b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
@@ -286,7 +286,7 @@ public class ServerChunkCache extends ChunkSource {
     }
     private CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> getChunkFutureMainThread(int chunkX, int chunkZ, ChunkStatus leastStatus, boolean create, boolean isUrgent) {
         // Paper start - rewrite chunk system
-        io.papermc.paper.util.TickThread.ensureTickThread(this.level, chunkX, chunkZ, "Scheduling chunk load off-main");
+        //io.papermc.paper.util.TickThread.ensureTickThread(this.level, chunkX, chunkZ, "Scheduling chunk load off-main");
         int minLevel = ChunkLevel.byStatus(leastStatus);
         io.papermc.paper.chunk.system.scheduling.NewChunkHolder chunkHolder = this.level.chunkTaskScheduler.chunkHolderManager.getChunkHolder(chunkX, chunkZ);
 
diff --git a/src/main/java/net/minecraft/server/level/ServerPlayer.java b/src/main/java/net/minecraft/server/level/ServerPlayer.java
index 24cbb385822eac5c8dd7959b06148ad2d96715ed..aa66467f99a626934d4fca99f11c4f570c1a1270 100644
--- a/src/main/java/net/minecraft/server/level/ServerPlayer.java
+++ b/src/main/java/net/minecraft/server/level/ServerPlayer.java
@@ -1295,7 +1295,7 @@ public class ServerPlayer extends Player {
     }
 
     private void respawn(java.util.function.Consumer<ServerPlayer> respawnComplete, boolean alive) {
-        io.papermc.paper.util.TickThread.ensureTickThread(this, "Cannot respawn entity async");
+        //io.papermc.paper.util.TickThread.ensureTickThread(this, "Cannot respawn entity async");
 
         this.getBukkitEntity(); // force bukkit entity to be created before TPing
 
@@ -1570,7 +1570,7 @@ public class ServerPlayer extends Player {
 
     @Override
     public boolean endPortalLogicAsync() {
-        io.papermc.paper.util.TickThread.ensureTickThread(this, "Cannot portal entity async");
+        //io.papermc.paper.util.TickThread.ensureTickThread(this, "Cannot portal entity async");
 
         if (this.level().getTypeKey() == LevelStem.END) {
             if (!this.canPortalAsync(false)) {
diff --git a/src/main/java/net/minecraft/world/entity/Entity.java b/src/main/java/net/minecraft/world/entity/Entity.java
index af07c9d24374b7d969f1e524ce0bbb2626a590b1..765500366e432748949bfc129f6162d6fb126a42 100644
--- a/src/main/java/net/minecraft/world/entity/Entity.java
+++ b/src/main/java/net/minecraft/world/entity/Entity.java
@@ -1027,7 +1027,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
 
     public void move(MoverType movementType, Vec3 movement) {
         // Paper start - detailed watchdog information
-        io.papermc.paper.util.TickThread.ensureTickThread("Cannot move an entity off-main");
+        //io.papermc.paper.util.TickThread.ensureTickThread("Cannot move an entity off-main");
         synchronized (this.posLock) {
             this.moveStartX = this.getX();
             this.moveStartY = this.getY();
@@ -3577,7 +3577,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
     }
 
     protected EntityTreeNode makePassengerTree() {
-        io.papermc.paper.util.TickThread.ensureTickThread(this, "Cannot read passengers off of the main thread");
+        //io.papermc.paper.util.TickThread.ensureTickThread(this, "Cannot read passengers off of the main thread");
 
         EntityTreeNode root = new EntityTreeNode(null, this);
         java.util.ArrayDeque<EntityTreeNode> queue = new java.util.ArrayDeque<>();
@@ -3603,7 +3603,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
     }
 
     protected EntityTreeNode detachPassengers() {
-        io.papermc.paper.util.TickThread.ensureTickThread(this, "Cannot adjust passengers/vehicle off of the main thread");
+        //io.papermc.paper.util.TickThread.ensureTickThread(this, "Cannot adjust passengers/vehicle off of the main thread");
 
         EntityTreeNode root = new EntityTreeNode(null, this);
         java.util.ArrayDeque<EntityTreeNode> queue = new java.util.ArrayDeque<>();
@@ -3785,7 +3785,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
     public final boolean teleportAsync(ServerLevel destination, Vec3 pos, Float yaw, Float pitch, Vec3 speedDirectionUpdate,
                                        org.bukkit.event.player.PlayerTeleportEvent.TeleportCause cause, long teleportFlags,
                                        java.util.function.Consumer<Entity> teleportComplete) {
-        io.papermc.paper.util.TickThread.ensureTickThread(this, "Cannot teleport entity async");
+        //io.papermc.paper.util.TickThread.ensureTickThread(this, "Cannot teleport entity async");
 
         if (!ServerLevel.isInSpawnableBounds(new BlockPos(io.papermc.paper.util.CoordinateUtils.getBlockX(pos), io.papermc.paper.util.CoordinateUtils.getBlockY(pos), io.papermc.paper.util.CoordinateUtils.getBlockZ(pos)))) {
             return false;
@@ -3901,7 +3901,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
     }
 
     protected boolean tryEndPortal() {
-        io.papermc.paper.util.TickThread.ensureTickThread(this, "Cannot portal entity async");
+        //io.papermc.paper.util.TickThread.ensureTickThread(this, "Cannot portal entity async");
         BlockPos pos = this.portalBlock;
         ServerLevel world = this.portalWorld;
         this.portalBlock = null;
@@ -3919,7 +3919,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
     }
 
     protected boolean tryNetherPortal() {
-        io.papermc.paper.util.TickThread.ensureTickThread(this, "Cannot portal entity async");
+        //io.papermc.paper.util.TickThread.ensureTickThread(this, "Cannot portal entity async");
 
         int portalWaitTime = this.getPortalWaitTime();
 
@@ -3942,7 +3942,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
     }
 
     public boolean endPortalLogicAsync() {
-        io.papermc.paper.util.TickThread.ensureTickThread(this, "Cannot portal entity async");
+        //io.papermc.paper.util.TickThread.ensureTickThread(this, "Cannot portal entity async");
 
         ServerLevel destination = this.getServer().getLevel(this.level().getTypeKey() == LevelStem.END ? Level.OVERWORLD : Level.END);
         EntityPortalReadyEvent event = new io.papermc.paper.event.entity.EntityPortalReadyEvent(this.getBukkitEntity(), destination == null ? null : destination.getWorld(), org.bukkit.PortalType.ENDER);
@@ -3960,7 +3960,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
     }
 
     public boolean netherPortalLogicAsync() {
-        io.papermc.paper.util.TickThread.ensureTickThread(this, "Cannot portal entity async");
+        //io.papermc.paper.util.TickThread.ensureTickThread(this, "Cannot portal entity async");
 
         ServerLevel destination = this.getServer().getLevel(this.level().getTypeKey() == LevelStem.NETHER ? Level.OVERWORLD : Level.NETHER);
         EntityPortalReadyEvent event = new io.papermc.paper.event.entity.EntityPortalReadyEvent(this.getBukkitEntity(), destination == null ? null : destination.getWorld(), org.bukkit.PortalType.NETHER);
@@ -4187,7 +4187,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
 
     protected boolean portalToAsync(ServerLevel destination, boolean takePassengers,
                                     PortalType type, java.util.function.Consumer<Entity> teleportComplete) {
-        io.papermc.paper.util.TickThread.ensureTickThread(this, "Cannot portal entity async");
+        //io.papermc.paper.util.TickThread.ensureTickThread(this, "Cannot portal entity async");
         if (!this.canPortalAsync(takePassengers)) {
             return false;
         }
@@ -5428,7 +5428,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
     @Override
     public final void setRemoved(Entity.RemovalReason reason) {
         // Paper start - rewrite chunk system
-        io.papermc.paper.util.TickThread.ensureTickThread(this, "Cannot remove entity off-main");
+        //io.papermc.paper.util.TickThread.ensureTickThread(this, "Cannot remove entity off-main");
         if (!((ServerLevel)this.level).getEntityLookup().canRemoveEntity(this)) {
             LOGGER.warn("Entity " + this + " is currently prevented from being removed from the world since it is processing section status updates", new Throwable());
             return;
diff --git a/src/main/java/net/minecraft/world/entity/ai/village/poi/PoiManager.java b/src/main/java/net/minecraft/world/entity/ai/village/poi/PoiManager.java
index 5150d447c9dc2f539446749c8bee102050bab4ed..bd068146c3e90512ca176ee33531d856621d955a 100644
--- a/src/main/java/net/minecraft/world/entity/ai/village/poi/PoiManager.java
+++ b/src/main/java/net/minecraft/world/entity/ai/village/poi/PoiManager.java
@@ -265,7 +265,7 @@ public class PoiManager extends SectionStorage<PoiSection> {
         int chunkY = io.papermc.paper.util.CoordinateUtils.getChunkSectionY(pos);
         int chunkZ = io.papermc.paper.util.CoordinateUtils.getChunkSectionZ(pos);
 
-        io.papermc.paper.util.TickThread.ensureTickThread(this.world, chunkX, chunkZ, "Accessing poi chunk off-main");
+        //io.papermc.paper.util.TickThread.ensureTickThread(this.world, chunkX, chunkZ, "Accessing poi chunk off-main");
 
         io.papermc.paper.chunk.system.scheduling.ChunkHolderManager manager = this.world.chunkTaskScheduler.chunkHolderManager;
         io.papermc.paper.chunk.system.poi.PoiChunk ret = manager.getPoiChunkIfLoaded(chunkX, chunkZ, true);
@@ -279,7 +279,7 @@ public class PoiManager extends SectionStorage<PoiSection> {
         int chunkY = io.papermc.paper.util.CoordinateUtils.getChunkSectionY(pos);
         int chunkZ = io.papermc.paper.util.CoordinateUtils.getChunkSectionZ(pos);
 
-        io.papermc.paper.util.TickThread.ensureTickThread(this.world, chunkX, chunkZ, "Accessing poi chunk off-main");
+        //io.papermc.paper.util.TickThread.ensureTickThread(this.world, chunkX, chunkZ, "Accessing poi chunk off-main");
 
         io.papermc.paper.chunk.system.scheduling.ChunkHolderManager manager = this.world.chunkTaskScheduler.chunkHolderManager;
 
@@ -302,7 +302,7 @@ public class PoiManager extends SectionStorage<PoiSection> {
         int chunkY = io.papermc.paper.util.CoordinateUtils.getChunkSectionY(pos);
         int chunkZ = io.papermc.paper.util.CoordinateUtils.getChunkSectionZ(pos);
 
-        io.papermc.paper.util.TickThread.ensureTickThread(this.world, chunkX, chunkZ, "Accessing poi chunk off-main");
+        //io.papermc.paper.util.TickThread.ensureTickThread(this.world, chunkX, chunkZ, "Accessing poi chunk off-main");
 
         io.papermc.paper.chunk.system.scheduling.ChunkHolderManager manager = this.world.chunkTaskScheduler.chunkHolderManager;
 
@@ -317,7 +317,7 @@ public class PoiManager extends SectionStorage<PoiSection> {
     public void onUnload(long coordinate) { // Paper - rewrite chunk system
         int chunkX = io.papermc.paper.util.MCUtil.getCoordinateX(coordinate);
         int chunkZ = io.papermc.paper.util.MCUtil.getCoordinateZ(coordinate);
-        io.papermc.paper.util.TickThread.ensureTickThread(this.world, chunkX, chunkZ, "Unloading poi chunk off-main");
+        //io.papermc.paper.util.TickThread.ensureTickThread(this.world, chunkX, chunkZ, "Unloading poi chunk off-main");
         for (int section = this.levelHeightAccessor.getMinSection(); section < this.levelHeightAccessor.getMaxSection(); ++section) {
             long sectionPos = SectionPos.asLong(chunkX, section, chunkZ);
             this.updateDistanceTracking(sectionPos);
@@ -327,7 +327,7 @@ public class PoiManager extends SectionStorage<PoiSection> {
     public void loadInPoiChunk(io.papermc.paper.chunk.system.poi.PoiChunk poiChunk) {
         int chunkX = poiChunk.chunkX;
         int chunkZ = poiChunk.chunkZ;
-        io.papermc.paper.util.TickThread.ensureTickThread(this.world, chunkX, chunkZ, "Loading poi chunk off-main");
+        //io.papermc.paper.util.TickThread.ensureTickThread(this.world, chunkX, chunkZ, "Loading poi chunk off-main");
         for (int sectionY = this.levelHeightAccessor.getMinSection(); sectionY < this.levelHeightAccessor.getMaxSection(); ++sectionY) {
             PoiSection section = poiChunk.getSection(sectionY);
             if (section != null && !section.isEmpty()) {
diff --git a/src/main/java/net/minecraft/world/entity/vehicle/MinecartCommandBlock.java b/src/main/java/net/minecraft/world/entity/vehicle/MinecartCommandBlock.java
index 1e1adbb68596bd8351ec77da67e6fd8139734b61..8a39f9a0cdbb5183ed80da5b07e6aaf9c9f65157 100644
--- a/src/main/java/net/minecraft/world/entity/vehicle/MinecartCommandBlock.java
+++ b/src/main/java/net/minecraft/world/entity/vehicle/MinecartCommandBlock.java
@@ -153,7 +153,7 @@ public class MinecartCommandBlock extends AbstractMinecart {
         // Folia start
         @Override
         public void threadCheck() {
-            io.papermc.paper.util.TickThread.ensureTickThread(MinecartCommandBlock.this, "Asynchronous sendSystemMessage to a command block");
+            //io.papermc.paper.util.TickThread.ensureTickThread(MinecartCommandBlock.this, "Asynchronous sendSystemMessage to a command block");
         }
         // Folia end
     }
diff --git a/src/main/java/net/minecraft/world/level/block/entity/CommandBlockEntity.java b/src/main/java/net/minecraft/world/level/block/entity/CommandBlockEntity.java
index 3698bae85063baec031a61d24ef3286703a9d04c..bf997ee6950e8771cd73fd805275532f86b87fc0 100644
--- a/src/main/java/net/minecraft/world/level/block/entity/CommandBlockEntity.java
+++ b/src/main/java/net/minecraft/world/level/block/entity/CommandBlockEntity.java
@@ -60,7 +60,7 @@ public class CommandBlockEntity extends BlockEntity {
         // Folia start
         @Override
         public void threadCheck() {
-            io.papermc.paper.util.TickThread.ensureTickThread((ServerLevel) CommandBlockEntity.this.level, CommandBlockEntity.this.worldPosition, "Asynchronous sendSystemMessage to a command block");
+            //io.papermc.paper.util.TickThread.ensureTickThread((ServerLevel) CommandBlockEntity.this.level, CommandBlockEntity.this.worldPosition, "Asynchronous sendSystemMessage to a command block");
         }
         // Folia end
 
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftServer.java b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
index 874422fc018076fb03b4d2bb9992c659ec3f3662..dc71085cf58682e79a7fb5a2c15d2ec883749346 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -1014,7 +1014,7 @@ public final class CraftServer implements Server {
 
         // Folia start - region threading
         if ((sender instanceof Entity entity)) {
-            io.papermc.paper.util.TickThread.ensureTickThread(((org.bukkit.craftbukkit.entity.CraftEntity)entity).getHandle(), "Dispatching command async");
+            //io.papermc.paper.util.TickThread.ensureTickThread(((org.bukkit.craftbukkit.entity.CraftEntity)entity).getHandle(), "Dispatching command async");
         } else if (sender instanceof ConsoleCommandSender console) {
             io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Dispatching command async");
         } else {
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
index 359e63edc6b48134ad0d9e0b48cf83bec292d7d6..4804ae17f038363d968d703a5d59d6ca1e0c6d93 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
@@ -916,13 +916,13 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
     @Override
     public boolean createExplosion(double x, double y, double z, float power, boolean setFire, boolean breakBlocks, Entity source) {
-        io.papermc.paper.util.TickThread.ensureTickThread(this.world, x, z, "Cannot create explosion asynchronously");
+        //io.papermc.paper.util.TickThread.ensureTickThread(this.world, x, z, "Cannot create explosion asynchronously");
         return !this.world.explode(source == null ? null : ((CraftEntity) source).getHandle(), x, y, z, power, setFire, breakBlocks ? net.minecraft.world.level.Level.ExplosionInteraction.MOB : net.minecraft.world.level.Level.ExplosionInteraction.NONE).wasCanceled;
     }
     // Paper start
     @Override
     public boolean createExplosion(Entity source, Location loc, float power, boolean setFire, boolean breakBlocks) {
-        io.papermc.paper.util.TickThread.ensureTickThread(this.world, loc.getX(), loc.getZ(), "Cannot create explosion asynchronously");
+        //io.papermc.paper.util.TickThread.ensureTickThread(this.world, loc.getX(), loc.getZ(), "Cannot create explosion asynchronously");
         return !world.explode(source != null ? ((org.bukkit.craftbukkit.entity.CraftEntity) source).getHandle() : null, loc.getX(), loc.getY(), loc.getZ(), power, setFire, breakBlocks ? net.minecraft.world.level.Level.ExplosionInteraction.MOB : net.minecraft.world.level.Level.ExplosionInteraction.NONE).wasCanceled;
     }
     // Paper end
@@ -2306,7 +2306,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
         if (sourceEntity != null && !Bukkit.isOwnedByCurrentRegion(sourceEntity)) {
             throw new IllegalStateException("Cannot send game event asynchronously");
         }
-        io.papermc.paper.util.TickThread.ensureTickThread(this.world, position.getX(), position.getZ(), "Cannot send game event asynchronously");
+        //io.papermc.paper.util.TickThread.ensureTickThread(this.world, position.getX(), position.getZ(), "Cannot send game event asynchronously");
         // Folia end - region threading
         getHandle().gameEvent(sourceEntity != null ? ((CraftEntity) sourceEntity).getHandle(): null, net.minecraft.core.registries.BuiltInRegistries.GAME_EVENT.get(org.bukkit.craftbukkit.util.CraftNamespacedKey.toMinecraft(gameEvent.getKey())), org.bukkit.craftbukkit.util.CraftVector.toBlockPos(position));
     }
diff --git a/src/main/java/org/bukkit/craftbukkit/block/CraftBlock.java b/src/main/java/org/bukkit/craftbukkit/block/CraftBlock.java
index d1c844ae943e752157812d92b14d43a83b5322ef..a880377194e5659240c4e448d7418f1fc444d9a4 100644
--- a/src/main/java/org/bukkit/craftbukkit/block/CraftBlock.java
+++ b/src/main/java/org/bukkit/craftbukkit/block/CraftBlock.java
@@ -160,7 +160,7 @@ public class CraftBlock implements Block {
     private void setData(final byte data, int flag) {
         // Folia start - region threading
         if (world instanceof ServerLevel serverWorld) {
-            io.papermc.paper.util.TickThread.ensureTickThread(serverWorld, position, "Cannot modify world asynchronously");
+            //io.papermc.paper.util.TickThread.ensureTickThread(serverWorld, position, "Cannot modify world asynchronously");
         }
         // Folia end - region threading
         this.world.setBlock(position, CraftMagicNumbers.getBlock(this.getType(), data), flag);
@@ -206,7 +206,7 @@ public class CraftBlock implements Block {
     public static boolean setTypeAndData(LevelAccessor world, BlockPos position, net.minecraft.world.level.block.state.BlockState old, net.minecraft.world.level.block.state.BlockState blockData, boolean applyPhysics) {
         // Folia start - region threading
         if (world instanceof ServerLevel serverWorld) {
-            io.papermc.paper.util.TickThread.ensureTickThread(serverWorld, position, "Cannot modify world asynchronously");
+            //io.papermc.paper.util.TickThread.ensureTickThread(serverWorld, position, "Cannot modify world asynchronously");
         }
         // Folia end - region threading
         // SPIGOT-611: need to do this to prevent glitchiness. Easier to handle this here (like /setblock) than to fix weirdness in tile entity cleanup
@@ -356,7 +356,7 @@ public class CraftBlock implements Block {
     public Biome getBiome() {
         // Folia start - region threading
         if (world instanceof ServerLevel serverWorld) {
-            io.papermc.paper.util.TickThread.ensureTickThread(serverWorld, position, "Cannot read world asynchronously");
+            //io.papermc.paper.util.TickThread.ensureTickThread(serverWorld, position, "Cannot read world asynchronously");
         }
         // Folia end - region threading
         return this.getWorld().getBiome(this.getX(), this.getY(), this.getZ());
@@ -367,7 +367,7 @@ public class CraftBlock implements Block {
     public Biome getComputedBiome() {
         // Folia start - region threading
         if (world instanceof ServerLevel serverWorld) {
-            io.papermc.paper.util.TickThread.ensureTickThread(serverWorld, position, "Cannot read world asynchronously");
+            //io.papermc.paper.util.TickThread.ensureTickThread(serverWorld, position, "Cannot read world asynchronously");
         }
         // Folia end - region threading
         return this.getWorld().getComputedBiome(this.getX(), this.getY(), this.getZ());
@@ -378,7 +378,7 @@ public class CraftBlock implements Block {
     public void setBiome(Biome bio) {
         // Folia start - region threading
         if (world instanceof ServerLevel serverWorld) {
-            io.papermc.paper.util.TickThread.ensureTickThread(serverWorld, position, "Cannot modify world asynchronously");
+            //io.papermc.paper.util.TickThread.ensureTickThread(serverWorld, position, "Cannot modify world asynchronously");
         }
         // Folia end - region threading
         this.getWorld().setBiome(this.getX(), this.getY(), this.getZ(), bio);
@@ -452,7 +452,7 @@ public class CraftBlock implements Block {
     public boolean isBlockFaceIndirectlyPowered(BlockFace face) {
         // Folia start - region threading
         if (world instanceof ServerLevel serverWorld) {
-            io.papermc.paper.util.TickThread.ensureTickThread(serverWorld, position, "Cannot read world asynchronously");
+            //io.papermc.paper.util.TickThread.ensureTickThread(serverWorld, position, "Cannot read world asynchronously");
         }
         // Folia end - region threading
         int power = this.world.getMinecraftWorld().getSignal(position, CraftBlock.blockFaceToNotch(face));
@@ -469,7 +469,7 @@ public class CraftBlock implements Block {
     public int getBlockPower(BlockFace face) {
         // Folia start - region threading
         if (world instanceof ServerLevel serverWorld) {
-            io.papermc.paper.util.TickThread.ensureTickThread(serverWorld, position, "Cannot read world asynchronously");
+            //io.papermc.paper.util.TickThread.ensureTickThread(serverWorld, position, "Cannot read world asynchronously");
         }
         // Folia end - region threading
         int power = 0;
@@ -560,7 +560,7 @@ public class CraftBlock implements Block {
     public boolean breakNaturally(ItemStack item, boolean triggerEffect, boolean dropExperience) {
         // Folia start - region threading
         if (world instanceof ServerLevel serverWorld) {
-            io.papermc.paper.util.TickThread.ensureTickThread(serverWorld, position, "Cannot modify world asynchronously");
+            //io.papermc.paper.util.TickThread.ensureTickThread(serverWorld, position, "Cannot modify world asynchronously");
         }
         // Folia end - region threading
         // Paper end
@@ -608,7 +608,7 @@ public class CraftBlock implements Block {
     public boolean applyBoneMeal(BlockFace face) {
         // Folia start - region threading
         if (world instanceof ServerLevel serverWorld) {
-            io.papermc.paper.util.TickThread.ensureTickThread(serverWorld, position, "Cannot modify world asynchronously");
+            //io.papermc.paper.util.TickThread.ensureTickThread(serverWorld, position, "Cannot modify world asynchronously");
         }
         // Folia end - region threading
         Direction direction = CraftBlock.blockFaceToNotch(face);
@@ -714,7 +714,7 @@ public class CraftBlock implements Block {
     public RayTraceResult rayTrace(Location start, Vector direction, double maxDistance, FluidCollisionMode fluidCollisionMode) {
         // Folia start - region threading
         if (this.world instanceof ServerLevel serverWorld) {
-            io.papermc.paper.util.TickThread.ensureTickThread(serverWorld, this.position, "Cannot read world asynchronously");
+            //io.papermc.paper.util.TickThread.ensureTickThread(serverWorld, this.position, "Cannot read world asynchronously");
         }
         // Folia end - region threading
         Preconditions.checkArgument(start != null, "Location start cannot be null");
@@ -760,7 +760,7 @@ public class CraftBlock implements Block {
     public boolean canPlace(BlockData data) {
         // Folia start - region threading
         if (this.world instanceof ServerLevel serverWorld) {
-            io.papermc.paper.util.TickThread.ensureTickThread(serverWorld, this.position, "Cannot read world asynchronously");
+            //io.papermc.paper.util.TickThread.ensureTickThread(serverWorld, this.position, "Cannot read world asynchronously");
         }
         // Folia end - region threading
         Preconditions.checkArgument(data != null, "BlockData cannot be null");
@@ -799,7 +799,7 @@ public class CraftBlock implements Block {
     public void tick() {
         // Folia start - region threading
         if (world instanceof ServerLevel serverWorld) {
-            io.papermc.paper.util.TickThread.ensureTickThread(serverWorld, position, "Cannot modify world asynchronously");
+            //io.papermc.paper.util.TickThread.ensureTickThread(serverWorld, position, "Cannot modify world asynchronously");
         }
         // Folia end - region threading
         net.minecraft.world.level.block.state.BlockState blockData = this.getNMS();
@@ -812,7 +812,7 @@ public class CraftBlock implements Block {
     public void randomTick() {
         // Folia start - region threading
         if (world instanceof ServerLevel serverWorld) {
-            io.papermc.paper.util.TickThread.ensureTickThread(serverWorld, position, "Cannot modify world asynchronously");
+            //io.papermc.paper.util.TickThread.ensureTickThread(serverWorld, position, "Cannot modify world asynchronously");
         }
         // Folia end - region threading
         net.minecraft.world.level.block.state.BlockState blockData = this.getNMS();
diff --git a/src/main/java/org/bukkit/craftbukkit/block/CraftBlock.java.rej b/src/main/java/org/bukkit/craftbukkit/block/CraftBlock.java.rej
new file mode 100644
index 0000000000000000000000000000000000000000..59dae7af74e21c8afda8795388e0e91232b646da
--- /dev/null
+++ b/src/main/java/org/bukkit/craftbukkit/block/CraftBlock.java.rej
@@ -0,0 +1,10 @@
+diff a/src/main/java/org/bukkit/craftbukkit/block/CraftBlock.java b/src/main/java/org/bukkit/craftbukkit/block/CraftBlock.java	(rejected hunks)
+@@ -795,7 +795,7 @@ public class CraftBlock implements Block {
+     public float getDestroySpeed(ItemStack itemStack, boolean considerEnchants) {
+         // Folia start - region threading
+         if (world instanceof ServerLevel serverWorld) {
+-            io.papermc.paper.util.TickThread.ensureTickThread(serverWorld, position, "Cannot read world asynchronously");
++            //io.papermc.paper.util.TickThread.ensureTickThread(serverWorld, position, "Cannot read world asynchronously");
+         }
+         // Folia end - region threading
+         net.minecraft.world.item.ItemStack nmsItemStack;
diff --git a/src/main/java/org/bukkit/craftbukkit/block/CraftBlockState.java b/src/main/java/org/bukkit/craftbukkit/block/CraftBlockState.java
index 38b4d0870d21467e415d5e84457706df80c15e23..002f5136815328d5b7f92c4ca5d6cc8ab0971acc 100644
--- a/src/main/java/org/bukkit/craftbukkit/block/CraftBlockState.java
+++ b/src/main/java/org/bukkit/craftbukkit/block/CraftBlockState.java
@@ -203,7 +203,7 @@ public class CraftBlockState implements BlockState {
 
         // Folia start - region threading
         if (access instanceof net.minecraft.server.level.ServerLevel serverWorld) {
-            io.papermc.paper.util.TickThread.ensureTickThread(serverWorld, position, "Cannot modify world asynchronously");
+            //io.papermc.paper.util.TickThread.ensureTickThread(serverWorld, position, "Cannot modify world asynchronously");
         }
         // Folia end - region threading
 
@@ -343,7 +343,7 @@ public class CraftBlockState implements BlockState {
     @Override
     public java.util.Collection<org.bukkit.inventory.ItemStack> getDrops(org.bukkit.inventory.ItemStack item, org.bukkit.entity.Entity entity) {
         // Folia start - region threading
-        io.papermc.paper.util.TickThread.ensureTickThread(world.getHandle(), position, "Cannot modify world asynchronously");
+        //io.papermc.paper.util.TickThread.ensureTickThread(world.getHandle(), position, "Cannot modify world asynchronously");
         // Folia end - region threading
         net.minecraft.world.item.ItemStack nms = org.bukkit.craftbukkit.inventory.CraftItemStack.asNMSCopy(item);
 
